{"ast":null,"code":"// array in local storage for registered users\n//let users = JSON.parse(localStorage.getItem('users')) || [];\nconst users_fakes = [{\n  id: 12345,\n  username: 'jlospino',\n  password: '12345',\n  firstName: 'Jose Luis',\n  lastName: 'Ospino Cueva',\n  photo: 'https://gravatar.com/avatar/99df085afff369ce0fc5199e7dd062d9?s=400&d=robohash&r=x'\n}];\n\nif (!localStorage.getItem('users')) {\n  localStorage.setItem('users', JSON.stringify(users_fakes));\n}\n\nlet users = JSON.parse(localStorage.getItem('users'));\nexport function configureFakeBackend() {\n  let realFetch = window.fetch;\n\n  window.fetch = function (url, opts) {\n    return new Promise((resolve, reject) => {\n      // wrap in timeout to simulate server api call\n      setTimeout(() => {\n        // authenticate\n        if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n          // get parameters from post request\n          let params = JSON.parse(opts.body); // find if any user matches login credentials\n\n          let filteredUsers = users.filter(user => {\n            return user.username === params.username && user.password === params.password;\n          });\n          console.log(opts);\n\n          if (filteredUsers.length) {\n            // if login details are valid return user details and fake jwt token\n            let user = filteredUsers[0];\n            let responseJson = {\n              id: user.id,\n              username: user.username,\n              firstName: user.firstName,\n              lastName: user.lastName,\n              token: 'fake-jwt-token'\n            };\n            resolve({\n              ok: true,\n              text: () => Promise.resolve(JSON.stringify(responseJson))\n            });\n          } else {\n            // else return error\n            reject('Username or password is incorrect');\n          }\n\n          return;\n        } // get user by id\n\n\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            // find user by id in users array\n            let urlParts = url.split('/');\n            let id = parseInt(urlParts[urlParts.length - 1]);\n            let matchedUsers = users.filter(user => {\n              return user.id === id;\n            });\n            let user = matchedUsers.length ? matchedUsers[0] : null; // respond 200 OK with user\n\n            resolve({\n              ok: true,\n              text: () => JSON.stringify(user)\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n\n          return;\n        } // pass through any requests not handled above\n\n\n        realFetch(url, opts).then(response => resolve(response));\n      }, 500);\n    });\n  };\n}","map":{"version":3,"names":["users_fakes","id","username","password","firstName","lastName","photo","localStorage","getItem","setItem","JSON","stringify","users","parse","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","console","log","length","responseJson","token","ok","text","match","headers","Authorization","urlParts","split","parseInt","matchedUsers","then","response"],"sources":["C:/Users/SERDAN-DESARROLLO/Desktop/VueJS/src/helpers/fake-backend.js"],"sourcesContent":["// array in local storage for registered users\r\n//let users = JSON.parse(localStorage.getItem('users')) || [];\r\n\r\n\r\nconst users_fakes = [\r\n    {\r\n        id: 12345,\r\n        username: 'jlospino',\r\n        password: '12345',\r\n        firstName: 'Jose Luis',\r\n        lastName: 'Ospino Cueva',\r\n        photo: 'https://gravatar.com/avatar/99df085afff369ce0fc5199e7dd062d9?s=400&d=robohash&r=x'\r\n    }\r\n]\r\n\r\nif(!localStorage.getItem('users')){\r\n    localStorage.setItem('users', JSON.stringify(users_fakes));\r\n}\r\n\r\nlet users = JSON.parse(localStorage.getItem('users'));\r\n\r\nexport function configureFakeBackend() {\r\n    let realFetch = window.fetch;\r\n    window.fetch = function (url, opts) {\r\n        return new Promise((resolve, reject) => {\r\n            // wrap in timeout to simulate server api call\r\n            setTimeout(() => {\r\n\r\n                // authenticate\r\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\r\n                    // get parameters from post request\r\n                    let params = JSON.parse(opts.body);\r\n\r\n                    // find if any user matches login credentials\r\n                    let filteredUsers = users.filter(user => {\r\n                        return user.username === params.username && user.password === params.password;\r\n                    });\r\n\r\n                    console.log(opts)\r\n\r\n                    if (filteredUsers.length) {\r\n                        // if login details are valid return user details and fake jwt token\r\n                        let user = filteredUsers[0];\r\n                        let responseJson = {\r\n                            id: user.id,\r\n                            username: user.username,\r\n                            firstName: user.firstName,\r\n                            lastName: user.lastName,\r\n                            token: 'fake-jwt-token'\r\n                        };\r\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\r\n                    } else {\r\n                        // else return error\r\n                        reject('Username or password is incorrect');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // get user by id\r\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        let urlParts = url.split('/');\r\n                        let id = parseInt(urlParts[urlParts.length - 1]);\r\n                        let matchedUsers = users.filter(user => { return user.id === id; });\r\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\r\n\r\n                        // respond 200 OK with user\r\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\r\n                    } else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        reject('Unauthorised');\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // pass through any requests not handled above\r\n                realFetch(url, opts).then(response => resolve(response));\r\n\r\n            }, 500);\r\n        });\r\n    }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}